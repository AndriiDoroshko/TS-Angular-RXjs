/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component } from '@angular/core';
import { FieldType } from '@ngx-formly/core';
export class FormlyFieldMultiCheckbox extends FieldType {
    constructor() {
        super(...arguments);
        this.defaultOptions = {
            templateOptions: {
                options: [],
                formCheck: 'custom',
            },
        };
    }
    /**
     * @param {?} value
     * @param {?} checked
     * @return {?}
     */
    onChange(value, checked) {
        if (this.to.type === 'array') {
            this.formControl.patchValue(checked
                ? [...(this.formControl.value || []), value]
                : [...(this.formControl.value || [])].filter((/**
                 * @param {?} o
                 * @return {?}
                 */
                o => o !== value)));
        }
        else {
            this.formControl.patchValue(Object.assign({}, this.formControl.value, { [value]: checked }));
        }
        this.formControl.markAsTouched();
    }
    /**
     * @param {?} option
     * @return {?}
     */
    isChecked(option) {
        /** @type {?} */
        const value = this.formControl.value;
        return value && (this.to.type === 'array'
            ? (value.indexOf(option.value) !== -1)
            : value[option.value]);
    }
}
FormlyFieldMultiCheckbox.decorators = [
    { type: Component, args: [{
                selector: 'formly-field-multicheckbox',
                template: `
    <div>
      <div *ngFor="let option of to.options | formlySelectOptions:field | async; let i = index;"
        [ngClass]="{
          'form-check': to.formCheck.indexOf('custom') === -1,
          'form-check-inline': to.formCheck === 'inline',
          'custom-control': to.formCheck.indexOf('custom') === 0,
          'custom-checkbox': to.formCheck === 'custom' || to.formCheck === 'custom-inline',
          'custom-control-inline': to.formCheck === 'custom-inline',
          'custom-switch': to.formCheck === 'custom-switch'
        }"
      >
        <input type="checkbox"
          [id]="id + '_' + i"
          [class.form-check-input]="to.formCheck.indexOf('custom') === -1"
          [class.custom-control-input]="to.formCheck.indexOf('custom') === 0"
          [value]="option.value"
          [checked]="isChecked(option)"
          [disabled]=" formControl.disabled || option.disabled"
          [formlyAttributes]="field"
          (change)="onChange(option.value, $event.target.checked)">
        <label
          [class.form-check-label]="to.formCheck.indexOf('custom') === -1"
          [class.custom-control-label]="to.formCheck.indexOf('custom') === 0"
          [for]="id + '_' + i">
          {{ option.label }}
        </label>
      </div>
    </div>
  `
            }] }
];
if (false) {
    /** @type {?} */
    FormlyFieldMultiCheckbox.prototype.defaultOptions;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXVsdGljaGVja2JveC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC8iLCJzb3VyY2VzIjpbImxpYi90eXBlcy9tdWx0aWNoZWNrYm94LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQW1DN0MsTUFBTSxPQUFPLHdCQUF5QixTQUFRLFNBQVM7SUFqQ3ZEOztRQWtDRSxtQkFBYyxHQUFHO1lBQ2YsZUFBZSxFQUFFO2dCQUNmLE9BQU8sRUFBRSxFQUFFO2dCQUNYLFNBQVMsRUFBRSxRQUFRO2FBQ3BCO1NBQ0YsQ0FBQztJQXVCSixDQUFDOzs7Ozs7SUFyQkMsUUFBUSxDQUFDLEtBQVUsRUFBRSxPQUFnQjtRQUNuQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtZQUM1QixJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxPQUFPO2dCQUNqQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDO2dCQUM1QyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNOzs7O2dCQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssRUFBQyxDQUMvRCxDQUFDO1NBQ0g7YUFBTTtZQUNMLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxtQkFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssSUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLE9BQU8sSUFBRyxDQUFDO1NBQzlFO1FBQ0QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUNuQyxDQUFDOzs7OztJQUVELFNBQVMsQ0FBQyxNQUFXOztjQUNiLEtBQUssR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUs7UUFFcEMsT0FBTyxLQUFLLElBQUksQ0FDZCxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksS0FBSyxPQUFPO1lBQ3RCLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUN4QixDQUFDO0lBQ0osQ0FBQzs7O1lBN0RGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsNEJBQTRCO2dCQUN0QyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJUO2FBQ0Y7Ozs7SUFFQyxrREFLRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmllbGRUeXBlIH0gZnJvbSAnQG5neC1mb3JtbHkvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Zvcm1seS1maWVsZC1tdWx0aWNoZWNrYm94JyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2PlxuICAgICAgPGRpdiAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIHRvLm9wdGlvbnMgfCBmb3JtbHlTZWxlY3RPcHRpb25zOmZpZWxkIHwgYXN5bmM7IGxldCBpID0gaW5kZXg7XCJcbiAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICdmb3JtLWNoZWNrJzogdG8uZm9ybUNoZWNrLmluZGV4T2YoJ2N1c3RvbScpID09PSAtMSxcbiAgICAgICAgICAnZm9ybS1jaGVjay1pbmxpbmUnOiB0by5mb3JtQ2hlY2sgPT09ICdpbmxpbmUnLFxuICAgICAgICAgICdjdXN0b20tY29udHJvbCc6IHRvLmZvcm1DaGVjay5pbmRleE9mKCdjdXN0b20nKSA9PT0gMCxcbiAgICAgICAgICAnY3VzdG9tLWNoZWNrYm94JzogdG8uZm9ybUNoZWNrID09PSAnY3VzdG9tJyB8fCB0by5mb3JtQ2hlY2sgPT09ICdjdXN0b20taW5saW5lJyxcbiAgICAgICAgICAnY3VzdG9tLWNvbnRyb2wtaW5saW5lJzogdG8uZm9ybUNoZWNrID09PSAnY3VzdG9tLWlubGluZScsXG4gICAgICAgICAgJ2N1c3RvbS1zd2l0Y2gnOiB0by5mb3JtQ2hlY2sgPT09ICdjdXN0b20tc3dpdGNoJ1xuICAgICAgICB9XCJcbiAgICAgID5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgW2lkXT1cImlkICsgJ18nICsgaVwiXG4gICAgICAgICAgW2NsYXNzLmZvcm0tY2hlY2staW5wdXRdPVwidG8uZm9ybUNoZWNrLmluZGV4T2YoJ2N1c3RvbScpID09PSAtMVwiXG4gICAgICAgICAgW2NsYXNzLmN1c3RvbS1jb250cm9sLWlucHV0XT1cInRvLmZvcm1DaGVjay5pbmRleE9mKCdjdXN0b20nKSA9PT0gMFwiXG4gICAgICAgICAgW3ZhbHVlXT1cIm9wdGlvbi52YWx1ZVwiXG4gICAgICAgICAgW2NoZWNrZWRdPVwiaXNDaGVja2VkKG9wdGlvbilcIlxuICAgICAgICAgIFtkaXNhYmxlZF09XCIgZm9ybUNvbnRyb2wuZGlzYWJsZWQgfHwgb3B0aW9uLmRpc2FibGVkXCJcbiAgICAgICAgICBbZm9ybWx5QXR0cmlidXRlc109XCJmaWVsZFwiXG4gICAgICAgICAgKGNoYW5nZSk9XCJvbkNoYW5nZShvcHRpb24udmFsdWUsICRldmVudC50YXJnZXQuY2hlY2tlZClcIj5cbiAgICAgICAgPGxhYmVsXG4gICAgICAgICAgW2NsYXNzLmZvcm0tY2hlY2stbGFiZWxdPVwidG8uZm9ybUNoZWNrLmluZGV4T2YoJ2N1c3RvbScpID09PSAtMVwiXG4gICAgICAgICAgW2NsYXNzLmN1c3RvbS1jb250cm9sLWxhYmVsXT1cInRvLmZvcm1DaGVjay5pbmRleE9mKCdjdXN0b20nKSA9PT0gMFwiXG4gICAgICAgICAgW2Zvcl09XCJpZCArICdfJyArIGlcIj5cbiAgICAgICAgICB7eyBvcHRpb24ubGFiZWwgfX1cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxufSlcbmV4cG9ydCBjbGFzcyBGb3JtbHlGaWVsZE11bHRpQ2hlY2tib3ggZXh0ZW5kcyBGaWVsZFR5cGUge1xuICBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgIG9wdGlvbnM6IFtdLFxuICAgICAgZm9ybUNoZWNrOiAnY3VzdG9tJywgLy8gJ2N1c3RvbScgfCAnY3VzdG9tLWlubGluZScgfCAnY3VzdG9tLXN3aXRjaCcgfCAnc3RhY2tlZCcgfCAnaW5saW5lJ1xuICAgIH0sXG4gIH07XG5cbiAgb25DaGFuZ2UodmFsdWU6IGFueSwgY2hlY2tlZDogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLnRvLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgIHRoaXMuZm9ybUNvbnRyb2wucGF0Y2hWYWx1ZShjaGVja2VkXG4gICAgICAgID8gWy4uLih0aGlzLmZvcm1Db250cm9sLnZhbHVlIHx8IFtdKSwgdmFsdWVdXG4gICAgICAgIDogWy4uLih0aGlzLmZvcm1Db250cm9sLnZhbHVlIHx8IFtdKV0uZmlsdGVyKG8gPT4gbyAhPT0gdmFsdWUpLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JtQ29udHJvbC5wYXRjaFZhbHVlKHsgLi4udGhpcy5mb3JtQ29udHJvbC52YWx1ZSwgW3ZhbHVlXTogY2hlY2tlZCB9KTtcbiAgICB9XG4gICAgdGhpcy5mb3JtQ29udHJvbC5tYXJrQXNUb3VjaGVkKCk7XG4gIH1cblxuICBpc0NoZWNrZWQob3B0aW9uOiBhbnkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZm9ybUNvbnRyb2wudmFsdWU7XG5cbiAgICByZXR1cm4gdmFsdWUgJiYgKFxuICAgICAgdGhpcy50by50eXBlID09PSAnYXJyYXknXG4gICAgICAgID8gKHZhbHVlLmluZGV4T2Yob3B0aW9uLnZhbHVlKSAhPT0gLTEpXG4gICAgICAgIDogdmFsdWVbb3B0aW9uLnZhbHVlXVxuICAgICk7XG4gIH1cbn1cbiJdfQ==